uthash User's Guide
===================
Troy D. Hanson <thanson@users.sourceforge.net>

include::sflogo.txt[]

A hash in C
-----------
This document is geared towards C programmers of UNIX systems. Since you're
reading this, chances are that you know a hash is used for looking up items
using a key. In scripting languages like Perl, hashes are used all the time. 
In C, hashes don't exist in the language itself. This software provides a hash
for C structures.  

What can it do?
~~~~~~~~~~~~~~~~~
This software supports four basic operations on hashes.

1. add
2. find
3. delete
4. iterate 

Is it fast?
~~~~~~~~~~~
Add, find and delete are constant-time operations. Whether the hash contains
ten items or ten million items, these operations take the same amount of time.

This hash aims to be minimalistic and efficient. It is around 300 lines of C.
It inlines automatically because it's implemented as macros. It's fast as long
as your key domain is evenly-distributed by the Bernstein hash function (see
Appendix A).

Is it a library?
~~~~~~~~~~~~~~~~
No, it's just a single header file: `uthash.h`.  All you need to do is copy
the header file into your project, and:

    #include "uthash.h"

You may then utilize the hash macros as explained below.

BSD licensed
~~~~~~~~~~~~
This software is made available under the BSD license. It is free and
open source. For the license text, see the LICENSE file in the distribution.

Obtaining uthash
~~~~~~~~~~~~~~~~
Please follow the link to download on the 
http://uthash.sourceforge.net[uthash home page].

Keys and values
---------------

A hash is comprised of structures. Each structure represents a key-value
association. Usually one field acts as the key, and the structure itself
is the value.

.Defining a structure that can be hashed
----------------------------------------------------------------------
#include "uthash.h"

struct my_struct {
    int id;                    /* key */
    char name[10];             
    UT_hash_handle hh;         /* makes this structure hashable */
};
----------------------------------------------------------------------

The structure itself, and its fields (including the key) can have any name,
and any data type. 

.Data type independence
******************************************************************************
The most surprising feature of this hash implementation might be that it is
type-independent. It does not require your structures or your key to adhere to
any particular datatype.  How is it possible to implement a type-independent
hash in a strongly-typed language?  In a word, macros.  All the hash code is
in the form of macros, whose arguments are typeless.  The only requirement is
that your structure must contain a field of the type `UT_hash_handle`.
******************************************************************************

[NOTE]
Just remember that, as with any hash, the keys have to be unique.

The UT_hash_handle field
~~~~~~~~~~~~~~~~~~~~~~~~
The `UT_hash_handle` field must be present in your structure in order to hash
it.  It is used for the internal bookkeeping that makes the hash work.  It
does not require initialization. It can be named anything, but you can
simplify matters by naming it `hh`. This allows you to use the shortcut
"convenience" macros to add, find and delete items.


Adding, finding, deleting and iterating
---------------------------------------

This section introduces the `HASH_ADD`, `HASH_FIND` and `HASH_DELETE` macros.
These are the only macros you would need in principle, but in practice it's
easier to use the "convenience macros" if your key is an integer or a string.
These macros, demonstrated below, have the form `HASH_ADD_INT`,
`HASH_FIND_STR`, etc. 

[TIP]
This section demonstrates the macros by example. For a more succinct listing,
see Appendix F: Macro Reference. 

Adding an item to the hash
~~~~~~~~~~~~~~~~~~~~~~~~~~
Your hash must be declared as a `NULL`-initialized pointer to your structure.
Then allocate and initialize your structure and call `HASH_ADD`. (Here we'll
use the convenient `HASH_ADD_INT` variation, which is specifically for hashes
with keys of type `int`.)

.Adding an item to a hash
----------------------------------------------------------------------
struct my_struct *users = NULL;    /* declare the hash head */

int add_user(int id, char *name) {
    struct my_struct *s;

    s = malloc(sizeof(struct my_struct));
    s->id = id;
    strcpy(s->name, name);
    HASH_ADD_INT( users, id, s );  /* hash, key field name, item */
}
----------------------------------------------------------------------

[NOTE]
.Key uniqueness
==============================================================================
Your application must enforce key uniqueness. In other words, do not add the
same key to the hash more than once. If you do, hash behavior will be undefined. 
==============================================================================

Finding an item in the hash
~~~~~~~~~~~~~~~~~~~~~~~~~~~

To look up an item in a hash, you must have its key.  Then call `HASH_FIND`.
(Here we'll use the convenient `HASH_FIND_INT` variation for keys of type
`int`).

.Looking up an item in a hash by its key
----------------------------------------------------------------------

struct my_struct *find_user(int id) {
    struct my_struct *s;

    HASH_FIND_INT( users, s, id, &id );  /* hash, output pointer, key field name, key pointer */
    return s;
}
----------------------------------------------------------------------

Here, `s` is the output variable of the `HASH_FIND_INT` macro. It's a pointer
to the sought item, or `NULL` if no item with the given key was found.

Deleting an item from the hash
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To delete an item from a hash, you must have a pointer to the item.

.Deleting an item from a hash
----------------------------------------------------------------------

void delete_user(struct my_struct *user) {
    HASH_DEL( users, user);  /* hash, pointer to deletee */
}
----------------------------------------------------------------------

[NOTE]
Deleting an item from a hash just removes it-- it does not free it. 

Iterating over the items in the hash
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can loop over the items in the hash by starting from the beginning and
following the `hh.next` pointer.

.Iterating over all the items in a hash
----------------------------------------------------------------------

void print_users() {
    struct my_struct *s;

    for(s=users; s != NULL; s=s->hh.next) {
        printf("user id %d: name %s\n", s->id, s->name);
    }
}
----------------------------------------------------------------------

There is also an `hh.prev` pointer you could use to iterate backwards through
the hash, starting from any known item.

.A hash is also a doubly-linked list
*******************************************************************************
As you can see from the `hh.prev` and `hh.next` fields inside of each
structure, you can iterate forward and backward through the items in the hash
as if they are a in a doubly-linked list.

The order is preserved as well. The items are in the order they were added,
(obviously, omitting any subsequently deleted items).
*******************************************************************************

Putting it all together: A complete Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We'll repeat all the code and embellish it with a `main()` function
so that you can try the code. If you place it in a file called `example.c` you
in the same directory as `uthash.h`, you can compile and run it like this:

    cc -o example example.c
    ./example

Follow the prompts to try the program, and type `Ctrl-C` when done.

.A complete program
----------------------------------------------------------------------
#include <stdio.h>   /* gets */
#include <stdlib.h>  /* atoi, malloc */
#include <string.h>  /* strcpy */
#include "uthash.h"

struct my_struct {
    int id;                    /* key */
    char name[10];             
    UT_hash_handle hh;         /* makes this structure hashable */
};

struct my_struct *users = NULL;

int add_user(int id, char *name) {
    struct my_struct *s;

    s = malloc(sizeof(struct my_struct));
    s->id = id;
    strcpy(s->name, name);
    HASH_ADD_INT( users, id, s );  /* hash, key field name, item */
}

struct my_struct *find_user(int id) {
    struct my_struct *s;

    HASH_FIND_INT( users, s, id, &id );  /* hash, output pointer, key field name, key pointer */
    return s;
}

void delete_user(struct my_struct *user) {
    HASH_DEL( users, user);  /* hash, pointer to deletee */
}

void print_users() {
    struct my_struct *s;

    for(s=users; s != NULL; s=s->hh.next) {
        printf("user id %d: name %s\n", s->id, s->name);
    }
}

int main(int argc, char *argv[]) {
    char in[10];
    int id=1;
    struct my_struct *s;

    while (1) {
        printf("1. add user\n");
        printf("2. find user\n");
        printf("3. delete user\n");
        printf("4. print users\n");
        gets(in);
        switch(atoi(in)) {
            case 1:
                printf("name?\n");
                add_user(id++, gets(in));
                break;
            case 2:
                printf("id?\n");
                s = find_user(atoi(gets(in)));
                printf("user: %s\n", s ? s->name : "unknown");
                break;
            case 3:
                printf("id?\n");
                s = find_user(atoi(gets(in)));
                if (s) delete_user(s);
                else printf("id unknown\n");
                break;
            case 4:
                print_users();
                break;
        }
    }
}
----------------------------------------------------------------------

Non-integer keys
----------------

An example with string keys
~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is almost the same as using integer keys except the convenience macros
are named `HASH_ADD_STR` and `HASH_FIND_STR`.

.A string-keyed hash
----------------------------------------------------------------------
#include <string.h>  /* strcpy */
#include <stdlib.h>  /* malloc */
#include "uthash.h"

struct my_struct {
    char name[10];             /* key */
    int id;                    
    UT_hash_handle hh;         /* makes this structure hashable */
};


int main(int argc, char *argv[]) {
    char **n, *names[] = { "joe", "bob", "betty", NULL };
    struct my_struct *s, *users = NULL;
    int i=0;

    /* build a hash: joe, bob and betty */
    for (n = names; *n != NULL; n++) {
        s = malloc(sizeof(struct my_struct));
        strcpy(s->name, *n);
        s->id = i++;
        HASH_ADD_STR( users, name, s );  /* hash, key field name, item */
    }

    /* args are hash, output pointer, key field name, key sought */
    HASH_FIND_STR( users, s, name, "betty");
    if (s) {
        printf("betty's id is %d\n", s->id);   /* prints "betty's id is 2" */
    }
}
----------------------------------------------------------------------

An example with an aggregate, binary key
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Your key field can have any data type, and it can even be an aggregate of
multiple contiguous fields. 

.Calculating aggregate key length 
*******************************************************************************
To determine the key length when using an aggregate key, you must include
any intervening structure padding the compiler adds for alignment purposes.

An easy way to calculate the key length is to use the `offsetof` macro from
`<stddef.h>`.  The formula is:

    key length = (last field offset + its length) - (first field offset)

In the example below, the `keylen` variable is set using this technique.
*******************************************************************************

The generalized version of the macros (e.g., `HASH_ADD`) are used in this
example, because the "convenience macros" (e.g. `HASH_ADD_STR`) only work for
non-aggregate integer or string keys.

.An aggregate, binary-keyed hash
----------------------------------------------------------------------
#include <sys/time.h>  /* gettimeofday */
#include <stdlib.h>    /* malloc       */
#include <stddef.h>    /* offsetof     */
#include <stdio.h>     /* printf       */
#include <string.h>    /* memset       */
#include <time.h>      /* ctime        */
#include "uthash.h"

struct my_event {
    struct timeval tv;         /* key is aggregate of this field */ 
    char event_code;           /* and this field.                */    
    int user_id;
    UT_hash_handle hh;         /* makes this structure hashable */
};


int main(int argc, char *argv[]) {
    struct my_event *e, ev, *events = NULL;
    int i, keylen;

    /* key length = (last field offset + its length) - first field offset */
    keylen =   offsetof(struct my_event, event_code) + sizeof(char)                         
             - offsetof(struct my_event, tv);

    for(i = 0; i < 10; i++) {
        e = malloc(sizeof(struct my_event));
        memset(e,0,sizeof(struct my_event));        
        e->tv.tv_sec = i * (60*60*24*365);          /* i years (sec)*/
        e->tv.tv_usec = 0;
        e->event_code = 'a'+(i%2);                   /* meaningless */
        e->user_id = i;

        /* args: UT_hash_handle name, head, first key field, key len, item */
        HASH_ADD( hh, events, tv, keylen, e);
    }

    /* iterate over events, printing them out */
    for(e=events; e != NULL; e=e->hh.next) {
        printf("user %d caused event %c on %s", 
                e->user_id, 
                e->event_code,
                ctime(&e->tv.tv_sec));
    }

    /* look for one specific event */
    memset(&ev,0,sizeof(struct my_event));
    ev.tv.tv_sec = 5 * (60*60*24*365);          
    ev.tv.tv_usec = 0;
    ev.event_code = 'b';
    HASH_FIND( hh, events, e, tv, &ev.tv, keylen );
    if (e) printf("event found: user %d\n", e->user_id);
    else printf("lookup failed\n");
}
----------------------------------------------------------------------

This example is included in the distribution in `tests/test16.c`.

.Zero-fill padding in an aggregate key 
*******************************************************************************
Notice the use of `memset` in the example above to initialize the structure 
by zero-filling it.  This might seem unnecessary, since the next lines
explicitly set each field. However, the `memset` is needed, because it zeroes
out any 'padding' that the compiler has inserted into the structure. 

If we didn't zero-fill the structure, padding within the aggregate key would 
be initialized with random values. This would make it impossible to lookup
items by their key reliably. (The aggregate key comprises the fields and their
intervening padding).
*******************************************************************************


Participating in multiple hashes
--------------------------------

Can my structure participate in more than one hash at the same time?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Yes, your structure can participate in 'n' hashes simultaneously, and each one
can have a different key field. For example, you might want to hash a
structure on both an ID field and on a unique username.

.A structure with two keys
----------------------------------------------------------------------
struct my_struct {
    int id;                    /* key 1 */
    char username[10];         /* key 2 */
    UT_hash_handle hh1,hh2;    /* makes this structure hashable */
};
----------------------------------------------------------------------

[NOTE]
You need to have a separate `UT_hash_handle` for each hash that your structure
will participate in simultaneously. These are `hh1` and `hh2` in this example.

.A structure participating in two hashes
----------------------------------------------------------------------
    struct my_struct *users_by_id = NULL, *users_by_name = NULL, *s;
    int i;
    char *name;

    s = malloc(sizeof(struct my_struct));
    s->id = 1;
    strcpy(s->username, "thanson");

    HASH_ADD(hh1, users_by_id, id, sizeof(int), s);
    HASH_ADD(hh2, users_by_name, username, strlen(s->username), s);

    /* lookup user by ID */
    i=1;
    HASH_FIND(hh1, users_by_id, s, id, &i, sizeof(int));
    if (s) printf("found id %d: %s\n", i, s->username);

    /* lookup user by username */
    name = "thanson";
    HASH_FIND(hh2, users_by_name, s, username, name, strlen(name));
    if (s) printf("found user %s: %d\n", name, s->id);
----------------------------------------------------------------------

When participating in two or more hashes simultaneously, always use the same
key field with the same hash handle.  E.g., in this example, `hh1` is always
used with the `id` key, and `hh2` is always used with the `username` key.

Appendix A: Bernstein's hash function
--------------------------------------
Internally this software uses a particular hash function, known as Bernstein's
hash, to transform a key to a bucket number. 

-----------------------------------------------------------------
/* The Bernstein hash function, used in Perl prior to v5.6 */
#define UT_HASH(key,keylen,num_bkts,bkt)                       \
  bkt = 0;                                                     \
  while (keylen--)  bkt = (bkt * 33) + *key++;                 \
  bkt &= (num_bkts-1);          
-----------------------------------------------------------------

In practice, most key domains map quite evenly among the buckets using
Bernstein's hash function. 

Alternative hash functions could distribute some key domains more evenly among
the buckets than Bernstein's function.  You can use your own hash function
instead of Bernstein's by re-defining the UT_HASH macro.

Appendix B: Statistic hash_q
----------------------------
The hash_q statistic measures how evenly the keys are distributed among the
buckets.  It is a value between 0 (worst) and 1 (best).  You can access it
in this way, if you're interested in observing how well your hash keys hold up
to the ideal distribution.

.Observing the hash_q statistic
----------------------------------------------------------------------

/* using the example "users" hash from previous listings */

void print_hashq() {
    if (users) printf("hash_q: %f\n", users->hh.tbl->hash_q);
}
----------------------------------------------------------------------

The hash_q statistic is updated whenever bucket expansion occurs (see Appendix C).

.What is hash_q?
*****************************************************************************
The 'n' items in a hash are distributed into 'k' buckets. Ideally each bucket
would contain an equal share '(n/k)' of the items. (I.e., the maximum linear
position of any item within a bucket would be 'n/k'.) The hash_q statistic
measures the fraction of items whose linear position is less than or equal to
the maximum ideal position 'n/k'. 

Said another way, 'hash_q' is the fraction of items which can be found using
no more than the ideal number of steps, given the number of items and buckets.
*****************************************************************************

A low value of `hash_q` may lead to reduced lookup (`HASH_FIND`) performance.
You can redefine the `UT_HASH` macro if you know a hash function that is more
appropriate for your key domain. (See Appendix A). For many key domains, the
built-in Bernstein hash function works satisfactorily.


Appendix C: Bucket expansion
----------------------------
Internally this hash manages the number of buckets, with the goal of having
enough buckets so that each one contains only small number of items.  

.Why does the number of buckets matter?
*****************************************************************************
When looking up an item by its key, this hash scans linearly through the items
in the appropriate bucket. In order for the linear scan to run in constant
time, the number of items in each bucket must be bounded. This is accomplished
by increasing the number of buckets as needed.
*****************************************************************************

This hash attempts to keep fewer than 10 items in each bucket. When an item is
added that would cause a bucket to exceed this number, the number of buckets in
the hash is doubled and the items are redistributed. 

[NOTE]
Bucket expansion occurs automatically and invisibly as needed. There is
no need for the application to know when it occurs. 

Bucket expansion hook
~~~~~~~~~~~~~~~~~~~~~
That said, there is a hook for this event, primarily for uthash development. 

.Bucket expansion hook
----------------------------------------------------------------------------
#include "uthash.h"

#undef uthash_expand_fyi 
#define uthash_expand_fyi(tbl) printf("expanded to %d buckets\n", tbl->num_buckets)

...
----------------------------------------------------------------------------

Bucket expansion inhibited hook
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Although it may be uncommon in practice, some key domains may not yield a good
bucket distribution using the built-in Bernstein hash function. 

If this occurs, statistic `hash_q` reflects the uneven distribution by tending
closer to 0 than 1.  This means that items are piling up in some buckets while
other buckets are under-utilized.  Bucket expansion then takes place as this
hash tries to keep a bounded number of items in each bucket.

However, if bucket expansion is not helping (i.e., items are still piled up
unevenly in some buckets afterward) then there is a point at which this hash
in effect says, '"it\'s not working, this key domain is really incompatible with
the Bernstein hash function, so I'm not going to waste time expanding buckets
any more."'

In technical terms, this decision is a heuristic rule: if two consecutive
bucket expansions yield `hash_q` values below 0.5, then the 'bucket expansion
inhibited' flag is set for this hash. 

Because this condition would cause `HASH_FIND` lookups to exhibit worse than
constant-time performance, your application can choose to be made aware if it
occurs. 

.Bucket expansion inhibited hook
----------------------------------------------------------------------------
#include "uthash.h"

#undef uthash_noexpand_fyi
#define uthash_noexpand_fyi printf("warning: bucket expansion inhibited\n");

...
----------------------------------------------------------------------------

Once set, the 'bucket expansion inhibited' flag remains in effect for the
lifetime of the hash (that is, until all its items are deleted, or the program
ends).


Appendix D: Hooks for memory allocation
----------------------------------------
By default this hash implementation uses `malloc` and `free` to manage memory.
If your application uses its own custom allocator, this hash can use them too.


.Specifying alternate memory management functions
----------------------------------------------------------------------------
#include "uthash.h"


/* undefine the defaults */
#undef uthash_bkt_malloc
#undef uthash_bkt_free
#undef uthash_tbl_malloc
#undef uthash_tbl_free

/* re-define specifying alternate functions */
#define uthash_bkt_malloc(sz) my_malloc(sz)  /* malloc for UT_hash_bucket's */
#define uthash_bkt_free(ptr) my_free(ptr)    /* free for UT_hash_bucket's   */
#define uthash_tbl_malloc(sz) my_malloc(sz)  /* malloc for UT_hash_table    */
#define uthash_tbl_free(ptr) my_free(ptr)    /* free for UT_hash_table      */

...
----------------------------------------------------------------------------

.Why are there two pairs of malloc/free functions?
*******************************************************************************
The first pair allocates and frees `UT_hash_bucket` structures,
while the second pair allocates and frees `UT_hash_table` structures. While
they don't 'need' to have separate allocation/free functions (and indeed the
default is just to use `malloc` and `free` anyway), having them separate
permits easy integration with pool or slab allocators where allocation from
each pool is always of the same fixed size.
*******************************************************************************

////////////////////////////////
diagram of hash 
1. buckets w/items
2. two items w/hash handles
////////////////////////////////


Appendix E: Internal implementation notes
-----------------------------------------

Application and bucket order
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The `UT_hash_handle` data structure contains `next`, `prev`, `hh_next` and
`hh_prev` fields.  The former two fields determine the "application" ordering
(that is, iteration order that corresponds to the order the items were added).
The latter two fields determine the "bucket" order.  These link the
`UT_hash_handles` together in a doubly-linked list that defines a bucket.

Internal consistency check with -DHASH_DEBUG=1 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If a program that uses this hash is compiled with `-DHASH_DEBUG=1`, a special
internal consistency-checking mode is activated.  In this mode, the integrity
of the whole hash is checked following every add or delete operation.

[NOTE]
This is for debugging the uthash software only, not for use in production code. 

In this mode, any internal errors in the hash data structure will cause a
message to be printed to `stderr` and the program to exit.

.Checks performed in `-DHASH_DEBUG=1` mode:
- the hash is walked in its entirety twice: once in 'bucket' order and a
  second time in 'application' order
- the total number of items encountered in both walks is checked against the
  stored number
- during the walk in 'bucket' order, each item's `hh_prev` pointer is compared
  for equality with the last visited item
- during the walk in 'application' order, each item's `prev` pointer is compared
  for equality with the last visited item

In the `tests/` directory, running `make debug` will run all the tests in
this mode.

Appendix F: Macro reference
---------------------------

Generalized macros
~~~~~~~~~~~~~~~~~~

These macros add, find and delete items from a hash.  

.Generalized macros
`---------------`-----------------------------------------------------------
macro           arguments
----------------------------------------------------------------------------
HASH_ADD        (hh_name, head, keyfield_name, key_len, item_ptr)
HASH_FIND       (hh_name, head, result_ptr, keyfield_name, key_ptr, key_len)
HASH_DELETE     (hh_name, head, item_ptr)
----------------------------------------------------------------------------

These arguments are described after the next section.

Convenience macros
~~~~~~~~~~~~~~~~~~
The convenience macros do the same thing as the generalized macros, but
require fewer arguments.  They have key and naming restrictions (see below).

.Convenience macros
`---------------`-----------------------------------------------------------
macro           arguments
----------------------------------------------------------------------------
HASH_ADD_INT    (head, keyfield_name, item_ptr)
HASH_FIND_INT   (head, result_ptr, keyfield_name, key_ptr)
HASH_ADD_STR    (head, keyfield_name, item_ptr)
HASH_FIND_STR   (head, result_ptr, keyfield_name, key_ptr)
HASH_DEL        (hh_name, head, item_ptr)
----------------------------------------------------------------------------

Key and naming restrictions for convenience macros
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
In order to use the convenience macros, the structure's `UT_hash_handle` field
must be named `hh`.  The key field must be of type `int` or pointer to `char`.
(For `HASH_DEL` the key field restriction does not apply.)

Argument descriptions
~~~~~~~~~~~~~~~~~~~~~
hh_name::
    name of the `UT_hash_handle` field in the structure. Conventionally called
    `hh`.
head::
    the structure pointer variable which acts as the "head" of the hash. So
    named because this hash can also be iterated over as a doubly-linked list.
keyfield_name::
    the name of the structure field which is the key (or in the case of an
    aggregate key, the first field of the key).
key_len::
    the length of the key field in bytes. E.g. for an integer key, this is
    `sizeof(int)`, while for a string key it's `strlen(key)`. For an aggregate
    key, see the notes in this guide on calculating aggregate key length.
key_ptr::
    pointer to the key being sought using `HASH_FIND`. I.e. this cannot be a
    literal value, it must be a pointer to a place in memory where the sought
    key is stored.
item_ptr::
    pointer to the structure being added or deleted
result_ptr::
    output pointer where `HASH_FIND` stores the address of the found item, or
    `NULL` if the item was not found

